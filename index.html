<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Periodic Delaunay-Voronoi - Three.js Visualization</title>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/",
            "poisson-disk-sampling": "https://esm.sh/poisson-disk-sampling@2.3.0"
        }
    }
    </script>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            width: 320px;
            transition: all 0.3s ease;
        }
        #controls-content {
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        .control-group {
            margin: 8px 0;
        }
        .control-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .control-row .control-group {
            flex: 1;
            margin: 0;
        }
        label {
            display: inline-block;
            width: 110px;
            font-size: 13px;
        }
        .control-row label {
            width: 80px;
        }
        input[type="number"] {
            width: 55px;
        }
        input[type="color"] {
            width: 30px;
            height: 25px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button {
            margin: 5px 0;
            padding: 5px 10px;
            width: 100%;
        }
        .section-header {
            font-weight: bold;
            margin: 15px 0 8px 0;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #controls-toggle {
            background: #007bff;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        #controls-toggle:hover {
            background: #0056b3;
        }
        #controls.hidden {
            width: auto;
            padding: 12px 16px;
        }
        #controls.hidden .section-header {
            margin: 0;
        }
        #controls.hidden #controls-toggle {
            padding: 8px 16px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .status { 
            font-size: 12px; 
            margin-top: 10px;
            padding: 5px;
            border-radius: 3px;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>

    
    <div id="controls" class="controls-container">
        <button id="controls-toggle" title="Hide Controls">hide</button>
        <div id="controls-content">
            <!-- Geometric Structure Controls - Now First -->
            <div class="section" id="geometric-controls">
                <div class="section-header">Geometric Structures</div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Object:</label>
                        <select id="pointDistribution">
                            <option value="voronoi">Voronoi</option>
                            <option value="tetrahedron">Tetrahedron</option>
                            <option value="cube">Cube</option>
                            <option value="octahedron">Octahedron</option>
                            <option value="dodecahedron">Dodecahedron</option>
                            <option value="icosahedron">Icosahedron</option>
                        </select>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Space-Filling:</label>
                        <select id="spaceFillingType">
                            <option value="none">None</option>
                            <option value="cubic_honeycomb">Cubic Honeycomb</option>
                            <option value="tet_oct_honeycomb">Tet-Oct Honeycomb</option>
                            <option value="truncated_octahedron">Truncated Octahedron</option>
                            <option value="rhombic_dodecahedron">Rhombic Dodecahedron</option>
                        </select>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Scale:</label>
                        <input type="range" id="geometricScale" value="0.3" min="0.1" max="0.8" step="0.05" class="slider">
                    </div>
                    <div class="control-group">
                        <label>Divisions:</label>
                        <input type="number" id="honeycombDivisions" value="3" min="2" max="8" step="1">
                    </div>
                </div>
            </div>
            
            <div class="section" id="main-controls">
                <div class="section-header">Controls</div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Points:</label>
                        <input type="number" id="numPoints" value="250" min="4" max="2500" step="1">
                    </div>
                    <div class="control-group">
                        <label>Min Dist:</label>
                        <input type="number" id="minDistance" value="0.05" min="0.01" max="0.2" step="0.01">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Motion:</label>
                        <input type="range" id="motionWander" value="0" min="0" max="0.1" step="0.001" class="slider">
                    </div>
                    <div class="control-group">
                        <label>Speed:</label>
                        <input type="range" id="motionSpeed" value="0" min="0" max="0.01" step="0.0001" class="slider">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Live Update:</label>
                        <input type="checkbox" id="liveUpdate">
                    </div>
                    <div class="control-group">
                        <label>Update Step:</label>
                        <input type="number" id="updateFrequency" value="10" min="1" max="60" step="1">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Periodic:</label>
                        <input type="checkbox" id="periodicMode">
                    </div>
                    <div class="control-group">
                        <label>Ghost Cells:</label>
                        <input type="checkbox" id="showGhostCells">
                    </div>
                    <div class="control-group">
                        <label>MIC:</label>
                        <input type="checkbox" id="useMIC">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Background:</label>
                        <input type="color" id="backgroundColor" value="#AAAAAA">
                    </div>
                    <div class="control-group">
                        <label>Boundary:</label>
                        <input type="checkbox" id="showBoundary" checked>
                    </div>
                    <div class="control-group">
                        <label>Poisson:</label>
                        <input type="checkbox" id="poissonSampling" checked>
                    </div>
                </div>
            </div>
            
            <div class="section" id="visualization-controls">
                <div class="section-header">Delaunay Triangles / Tetrahedra</div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Vertices:</label>
                        <input type="checkbox" id="showVertices" checked>
                    </div>
                    <div class="control-group">
                        <label>Delaunay:</label>
                        <input type="checkbox" id="showDelaunay" checked>
                    </div>
                    <div class="control-group">
                        <label>Tetrahedra:</label>
                        <input type="checkbox" id="showTetrahedra" checked>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Point Size:</label>
                        <input type="number" id="delaunaySize" value="0.005" min="0.005" max="0.05" step="0.005">
                    </div>
                    <div class="control-group">
                        <label>Color:</label>
                        <input type="color" id="vertexColor" value="#000000">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Edge Width:</label>
                        <input type="number" id="delaunayEdgeWidth" value="2" min="1" max="5" step="1">
                    </div>
                    <div class="control-group">
                        <label>Color:</label>
                        <input type="color" id="delaunayEdgeColor" value="#808080">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Tetra Color:</label>
                        <input type="color" id="tetraColor" value="#808080">
                    </div>
                    <div class="control-group">
                        <label>Opacity:</label>
                        <input type="number" id="tetraOpacity" value="0.025" min="0.0" max="1.0" step="0.01">
                    </div>
                </div>
                
                <div class="section-header">Voronoi Diagrams / Objects</div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Voronoi:</label>
                        <input type="checkbox" id="showVoronoi" checked>
                    </div>
                    <div class="control-group">
                        <label>Faces:</label>
                        <input type="checkbox" id="showVoronoiFaces" checked>
                    </div>
                    <div class="control-group">
                        <label>Random:</label>
                        <input type="checkbox" id="randomVoronoiColors" checked>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Point Size:</label>
                        <input type="number" id="voronoiSize" value="0.0025" min="0.0005" max="0.05" step="0.0005">
                    </div>
                    <div class="control-group">
                        <label>Color:</label>
                        <input type="color" id="voronoiVertexColor" value="#CCCCCC">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Edge Width:</label>
                        <input type="number" id="voronoiEdgeWidth" value="3" min="1" max="5" step="1">
                    </div>
                    <div class="control-group">
                        <label>Color:</label>
                        <input type="color" id="voronoiEdgeColor" value="#000000">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Face Color:</label>
                        <input type="color" id="voronoiFaceColor" value="#32CD32">
                    </div>
                    <div class="control-group">
                        <label>Opacity:</label>
                        <input type="number" id="voronoiFaceOpacity" value="0.25" min="0.0" max="1.0" step="0.01">
                    </div>
                </div>
                
                <button id="regenerate">Generate New Points</button>
                <button id="recompute">Recompute Triangulation</button>
                <div id="status" class="status"></div>
            </div>
        </div>
    </div>
    
    <script src="dist/periodic_delaunay.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
        import { DelaunayComputation } from './src/js/DelaunayComputation.js';
        import PoissonDiskSampling from 'poisson-disk-sampling';
        
        let scene, camera, renderer, controls;
        let verticesGroup, delaunayGroup, voronoiGroup, tetrahedraGroup, boundaryGroup, voronoiFacesGroup;
        let mainCellGroup, ghostCellsGroup; // NEW: Groups for ghost cell tiling
        let Module;
        let currentPoints = [];
        let computation = null;
        let velocities = [];
        let frameCount = 0;
        
        // Initialize Three.js
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xAAAAAA);
            
            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.set(1.5, 1.5, 1.5);
            camera.lookAt(0.5, 0.5, 0.5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0.5, 0.5, 0.5);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Groups
            verticesGroup = new THREE.Group();
            delaunayGroup = new THREE.Group();
            voronoiGroup = new THREE.Group();
            tetrahedraGroup = new THREE.Group();
            boundaryGroup = new THREE.Group();
            voronoiFacesGroup = new THREE.Group();
            
            // NEW: Ghost cell groups
            mainCellGroup = new THREE.Group();
            ghostCellsGroup = new THREE.Group();
            
            // Add main cell groups to the main cell container
            mainCellGroup.add(verticesGroup);
            mainCellGroup.add(delaunayGroup);
            mainCellGroup.add(voronoiGroup);
            mainCellGroup.add(tetrahedraGroup);
            mainCellGroup.add(voronoiFacesGroup);
            
            scene.add(mainCellGroup);
            scene.add(boundaryGroup); // Boundary stays separate
            scene.add(ghostCellsGroup);
            
            // Create boundary box
            createBoundaryBox();
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Update resolution for LineMaterial
            delaunayGroup.children.forEach(child => {
                if (child.material && child.material.isLineMaterial) {
                    child.material.resolution.set(window.innerWidth, window.innerHeight);
                }
            });
            voronoiGroup.children.forEach(child => {
                if (child.material && child.material.isLineMaterial) {
                    child.material.resolution.set(window.innerWidth, window.innerHeight);
                }
            });
        }
        
        function createBoundaryBox() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 })
            );
            line.position.set(0.5, 0.5, 0.5);
            boundaryGroup.add(line);
            
            // Add axes helpers
            const axesHelper = new THREE.AxesHelper(0.2);
            scene.add(axesHelper);
        }
        
        // Generate well-distributed points using Poisson disk sampling
        function generatePoissonPoints(targetCount, minDistance) {
            console.log(`Generating ~${targetCount} points with min distance ${minDistance}...`);
            
            // For now, use a simpler approach that works better
            const points = [];
            const maxAttempts = targetCount * 100;
            let attempts = 0;
            
            // Add small margin to keep points away from boundaries
            const margin = 0.01;
            
            while (points.length < targetCount && attempts < maxAttempts) {
                attempts++;
                const newPoint = [
                    margin + Math.random() * (1 - 2 * margin),
                    margin + Math.random() * (1 - 2 * margin),
                    margin + Math.random() * (1 - 2 * margin)
                ];
                
                // Check minimum distance to existing points
                let tooClose = false;
                for (const point of points) {
                    const dx = newPoint[0] - point[0];
                    const dy = newPoint[1] - point[1];
                    const dz = newPoint[2] - point[2];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist < minDistance) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    points.push(newPoint);
                }
            }
            
            console.log(`Generated ${points.length} points with minimum distance checking`);
            return points;
        }
        
        // Legacy function for comparison (keeping for now)
        function generateWellDistributedPoints(count, minDist) {
            const points = [];
            let attempts = 0;
            const maxAttempts = count * 1000;
            
            while (points.length < count && attempts < maxAttempts) {
                attempts++;
                const newPoint = [Math.random(), Math.random(), Math.random()];
                
                // Check distance to existing points
                let tooClose = false;
                for (const point of points) {
                    const dx = newPoint[0] - point[0];
                    const dy = newPoint[1] - point[1];
                    const dz = newPoint[2] - point[2];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist < minDist) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    points.push(newPoint);
                }
            }
            
            return points;
        }
        
        // Helper function to calculate minimum image for periodic boundaries
        function getMinimumImage(p1, p2) {
            let dx = p2[0] - p1[0];
            let dy = p2[1] - p1[1];
            let dz = p2[2] - p1[2];

            // Apply periodic boundary conditions
            if (dx > 0.5) dx -= 1.0; else if (dx < -0.5) dx += 1.0;
            if (dy > 0.5) dy -= 1.0; else if (dy < -0.5) dy += 1.0;
            if (dz > 0.5) dz -= 1.0; else if (dz < -0.5) dz += 1.0;

            return [p1[0] + dx, p1[1] + dy, p1[2] + dz];
        }

        // =============================================================================
        // GEOMETRIC POINT GENERATORS
        // =============================================================================

        // Helper function to normalize and center points in unit cube
        function normalizeAndCenter(vertices, scale = 0.3, center = [0.5, 0.5, 0.5]) {
            // Find bounding box
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            for (const v of vertices) {
                minX = Math.min(minX, v[0]);
                maxX = Math.max(maxX, v[0]);
                minY = Math.min(minY, v[1]);
                maxY = Math.max(maxY, v[1]);
                minZ = Math.min(minZ, v[2]);
                maxZ = Math.max(maxZ, v[2]);
            }
            
            // Calculate current center and size
            const currentCenter = [(minX + maxX) / 2, (minY + maxY) / 2, (minZ + maxZ) / 2];
            const currentSize = Math.max(maxX - minX, maxY - minY, maxZ - minZ);
            
            // Normalize and scale
            return vertices.map(v => [
                center[0] + (v[0] - currentCenter[0]) * scale / currentSize,
                center[1] + (v[1] - currentCenter[1]) * scale / currentSize,
                center[2] + (v[2] - currentCenter[2]) * scale / currentSize
            ]);
        }

        // PLATONIC SOLIDS - Generate exact vertex coordinates
        function generateTetrahedronPoints(scale = 0.3, center = [0.5, 0.5, 0.5]) {
            // Regular tetrahedron vertices (inscribed in cube)
            const vertices = [
                [1, 1, 1],
                [1, -1, -1],
                [-1, 1, -1],
                [-1, -1, 1]
            ];
            
            console.log(`Generated tetrahedron with ${vertices.length} vertices`);
            return normalizeAndCenter(vertices, scale, center);
        }

        function generateCubePoints(scale = 0.3, center = [0.5, 0.5, 0.5]) {
            // Cube vertices
            const vertices = [
                [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],  // bottom face
                [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]       // top face
            ];
            
            console.log(`Generated cube with ${vertices.length} vertices`);
            return normalizeAndCenter(vertices, scale, center);
        }

        function generateOctahedronPoints(scale = 0.3, center = [0.5, 0.5, 0.5]) {
            // Octahedron vertices (dual of cube)
            const vertices = [
                [1, 0, 0], [-1, 0, 0],   // x-axis
                [0, 1, 0], [0, -1, 0],   // y-axis
                [0, 0, 1], [0, 0, -1]    // z-axis
            ];
            
            console.log(`Generated octahedron with ${vertices.length} vertices`);
            return normalizeAndCenter(vertices, scale, center);
        }

        function generateDodecahedronPoints(scale = 0.3, center = [0.5, 0.5, 0.5]) {
            // Dodecahedron vertices using golden ratio
            const phi = (1 + Math.sqrt(5)) / 2;  // Golden ratio
            const invPhi = 1 / phi;
            
            const vertices = [
                // Cube vertices
                [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],
                [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],
                // Rectangle in xy-plane
                [0, invPhi, phi], [0, invPhi, -phi], [0, -invPhi, phi], [0, -invPhi, -phi],
                // Rectangle in xz-plane
                [invPhi, phi, 0], [invPhi, -phi, 0], [-invPhi, phi, 0], [-invPhi, -phi, 0],
                // Rectangle in yz-plane
                [phi, 0, invPhi], [phi, 0, -invPhi], [-phi, 0, invPhi], [-phi, 0, -invPhi]
            ];
            
            console.log(`Generated dodecahedron with ${vertices.length} vertices`);
            return normalizeAndCenter(vertices, scale, center);
        }

        function generateIcosahedronPoints(scale = 0.3, center = [0.5, 0.5, 0.5]) {
            // Icosahedron vertices using golden ratio
            const phi = (1 + Math.sqrt(5)) / 2;  // Golden ratio
            
            const vertices = [
                // Rectangle in xy-plane
                [0, 1, phi], [0, 1, -phi], [0, -1, phi], [0, -1, -phi],
                // Rectangle in xz-plane
                [1, phi, 0], [1, -phi, 0], [-1, phi, 0], [-1, -phi, 0],
                // Rectangle in yz-plane
                [phi, 0, 1], [phi, 0, -1], [-phi, 0, 1], [-phi, 0, -1]
            ];
            
            console.log(`Generated icosahedron with ${vertices.length} vertices`);
            return normalizeAndCenter(vertices, scale, center);
        }

        // SPACE-FILLING POLYHEDRA - Generate honeycomb structures
        function generateCubicHoneycomb(divisions = 3) {
            const points = [];
            const step = 1.0 / divisions;
            
            // Generate grid points
            for (let i = 0; i <= divisions; i++) {
                for (let j = 0; j <= divisions; j++) {
                    for (let k = 0; k <= divisions; k++) {
                        points.push([i * step, j * step, k * step]);
                    }
                }
            }
            
            console.log(`Generated cubic honeycomb with ${points.length} points (${divisions}x${divisions}x${divisions} grid)`);
            return points;
        }

        function generateTetOctHoneycomb(divisions = 3) {
            const points = [];
            const step = 1.0 / divisions;
            
            // Generate alternating tetrahedra and octahedra centers
            for (let i = 0; i < divisions; i++) {
                for (let j = 0; j < divisions; j++) {
                    for (let k = 0; k < divisions; k++) {
                        const x = (i + 0.5) * step;
                        const y = (j + 0.5) * step;
                        const z = (k + 0.5) * step;
                        
                        // Add tetrahedron center
                        points.push([x, y, z]);
                        
                        // Add octahedron centers (offset pattern)
                        if ((i + j + k) % 2 === 0) {
                            points.push([x + step/2, y, z]);
                            points.push([x, y + step/2, z]);
                            points.push([x, y, z + step/2]);
                        }
                    }
                }
            }
            
            console.log(`Generated tetrahedral-octahedral honeycomb with ${points.length} points`);
            return points;
        }

        function generateTruncatedOctahedron(divisions = 3) {
            const points = [];
            const step = 1.0 / divisions;
            
            // Body-centered cubic lattice
            for (let i = 0; i < divisions; i++) {
                for (let j = 0; j < divisions; j++) {
                    for (let k = 0; k < divisions; k++) {
                        // Corner points
                        points.push([i * step, j * step, k * step]);
                        
                        // Body-centered points
                        if (i < divisions - 1 && j < divisions - 1 && k < divisions - 1) {
                            points.push([
                                (i + 0.5) * step,
                                (j + 0.5) * step,
                                (k + 0.5) * step
                            ]);
                        }
                    }
                }
            }
            
            console.log(`Generated truncated octahedron honeycomb with ${points.length} points`);
            return points;
        }

        function generateRhombicDodecahedron(divisions = 3) {
            const points = [];
            const step = 1.0 / divisions;
            
            // Face-centered cubic lattice
            for (let i = 0; i < divisions; i++) {
                for (let j = 0; j < divisions; j++) {
                    for (let k = 0; k < divisions; k++) {
                        const x = i * step;
                        const y = j * step;
                        const z = k * step;
                        
                        // Corner point
                        points.push([x, y, z]);
                        
                        // Face-centered points
                        if (i < divisions - 1 && j < divisions - 1) {
                            points.push([x + step/2, y + step/2, z]);
                        }
                        if (i < divisions - 1 && k < divisions - 1) {
                            points.push([x + step/2, y, z + step/2]);
                        }
                        if (j < divisions - 1 && k < divisions - 1) {
                            points.push([x, y + step/2, z + step/2]);
                        }
                    }
                }
            }
            
            console.log(`Generated rhombic dodecahedron honeycomb with ${points.length} points`);
            return points;
        }

        // =============================================================================
        // GEOMETRIC SHAPE VISUALIZATION (replaces Voronoi when geometric shapes selected)
        // =============================================================================

        function drawGeometricShapes() {
            // Clear existing Voronoi visualization (this is now the main drawing function for geometric objects)
            voronoiGroup.clear();
            voronoiFacesGroup.clear();
            
            const pointDistribution = document.getElementById('pointDistribution').value;
            const spaceFillingType = document.getElementById('spaceFillingType').value;
            const scale = parseFloat(document.getElementById('geometricScale').value);
            const divisions = parseInt(document.getElementById('honeycombDivisions').value);
            
            console.log(`drawGeometricShapes: pointDistribution=${pointDistribution}, spaceFillingType=${spaceFillingType}`);
            
            // Only draw geometric shapes if we're not using voronoi
            if (pointDistribution === 'voronoi') {
                console.log('Returning early - pointDistribution is voronoi');
                return; // Let normal Voronoi visualization handle this
            }
            
            // Handle space-filling structures
            if (spaceFillingType !== 'none') {
                console.log('Drawing space-filling structure:', spaceFillingType);
                drawSpaceFillingStructure(spaceFillingType, divisions);
                return;
            }
            
            // Handle individual Platonic solids
            console.log('Drawing Platonic solid:', pointDistribution);
            drawPlatonicSolid(pointDistribution, scale);
        }

        function drawPlatonicSolid(shapeType, scale) {
            const center = [0.5, 0.5, 0.5];
            
            // Get settings from Voronoi panel
            const voronoiFaceColorHex = document.getElementById('voronoiFaceColor').value;
            const voronoiFaceColorInt = parseInt(voronoiFaceColorHex.substring(1), 16);
            const opacity = parseFloat(document.getElementById('voronoiFaceOpacity').value);
            const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
            const voronoiEdgeColorInt = parseInt(voronoiEdgeColorHex.substring(1), 16);
            const useRandomColors = document.getElementById('randomVoronoiColors').checked;
            
            // Create wireframe material using Voronoi edge color
            const wireframeMaterial = new THREE.LineBasicMaterial({ 
                color: voronoiEdgeColorInt,
                linewidth: 2
            });
            
            // Create solid material using Voronoi face settings
            let solidMaterial;
            if (useRandomColors) {
                const randomColor = generateRandomColor(0); // Use index 0 for single shape
                solidMaterial = new THREE.MeshPhongMaterial({ 
                    color: randomColor,
                    opacity: opacity,
                    transparent: true,
                    side: THREE.DoubleSide,
                    flatShading: true  // This ensures flat faces, not smooth triangulated surfaces
                });
            } else {
                solidMaterial = new THREE.MeshPhongMaterial({ 
                    color: voronoiFaceColorInt,
                    opacity: opacity,
                    transparent: true,
                    side: THREE.DoubleSide,
                    flatShading: true  // This ensures flat faces, not smooth triangulated surfaces
                });
            }
            
            let geometry;
            
            switch (shapeType) {
                case 'tetrahedron':
                    geometry = new THREE.TetrahedronGeometry(scale, 0); // 0 detail = flat faces
                    break;
                case 'cube':
                    // Create custom cube geometry to show proper square faces
                    geometry = createCubeWithSquareFaces(scale);
                    break;
                case 'octahedron':
                    geometry = new THREE.OctahedronGeometry(scale, 0); // 0 detail = flat faces
                    break;
                case 'dodecahedron':
                    geometry = new THREE.DodecahedronGeometry(scale, 0); // 0 detail = flat faces
                    break;
                case 'icosahedron':
                    geometry = new THREE.IcosahedronGeometry(scale, 0); // 0 detail = flat faces
                    break;
                default:
                    return;
            }
            
            // Create solid mesh
            const solidMesh = new THREE.Mesh(geometry, solidMaterial);
            solidMesh.position.set(center[0], center[1], center[2]);
            voronoiFacesGroup.add(solidMesh);
            
            // Create custom wireframe that shows only the actual edges
            if (document.getElementById('showVoronoi').checked) {
                const edgeGeometry = createPolyhedronEdges(shapeType, scale);
                const edgeMesh = new THREE.LineSegments(edgeGeometry, wireframeMaterial);
                edgeMesh.position.set(center[0], center[1], center[2]);
                voronoiGroup.add(edgeMesh);
            }
            
            console.log(`Drew ${shapeType} with scale ${scale} using Voronoi panel settings`);
        }

        // Create custom cube geometry that properly represents square faces
        function createCubeWithSquareFaces(size) {
            const geometry = new THREE.BoxGeometry(size, size, size, 1, 1, 1);
            
            // The BoxGeometry creates 12 triangles (2 per face), but we want to make it look like 6 square faces
            // We'll use vertex colors or face groups to distinguish the faces
            geometry.computeVertexNormals();
            
            return geometry;
        }

        // Create clean edges for polyhedra without showing triangulation
        function createPolyhedronEdges(shapeType, scale) {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            
            const halfScale = scale / 2;
            
            switch (shapeType) {
                case 'cube':
                    // Define the 12 edges of a cube
                    const cubeVertices = [
                        [-halfScale, -halfScale, -halfScale], [halfScale, -halfScale, -halfScale],
                        [halfScale, halfScale, -halfScale], [-halfScale, halfScale, -halfScale],
                        [-halfScale, -halfScale, halfScale], [halfScale, -halfScale, halfScale],
                        [halfScale, halfScale, halfScale], [-halfScale, halfScale, halfScale]
                    ];
                    
                    // Define edges as pairs of vertex indices
                    const cubeEdges = [
                        [0, 1], [1, 2], [2, 3], [3, 0], // bottom face
                        [4, 5], [5, 6], [6, 7], [7, 4], // top face
                        [0, 4], [1, 5], [2, 6], [3, 7]  // vertical edges
                    ];
                    
                    for (const edge of cubeEdges) {
                        positions.push(...cubeVertices[edge[0]]);
                        positions.push(...cubeVertices[edge[1]]);
                    }
                    break;
                    
                case 'tetrahedron':
                    // For other shapes, use the built-in geometry edges
                    const tetGeometry = new THREE.TetrahedronGeometry(scale, 0);
                    return new THREE.EdgesGeometry(tetGeometry);
                    
                case 'octahedron':
                    const octGeometry = new THREE.OctahedronGeometry(scale, 0);
                    return new THREE.EdgesGeometry(octGeometry);
                    
                case 'dodecahedron':
                    const dodGeometry = new THREE.DodecahedronGeometry(scale, 0);
                    return new THREE.EdgesGeometry(dodGeometry);
                    
                case 'icosahedron':
                    const icoGeometry = new THREE.IcosahedronGeometry(scale, 0);
                    return new THREE.EdgesGeometry(icoGeometry);
            }
            
            if (positions.length > 0) {
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            }
            
            return geometry;
        }

        function drawSpaceFillingStructure(structureType, divisions) {
            const step = 1.0 / divisions;
            
            // Get settings from Voronoi panel
            const voronoiFaceColorHex = document.getElementById('voronoiFaceColor').value;
            const voronoiFaceColorInt = parseInt(voronoiFaceColorHex.substring(1), 16);
            const opacity = parseFloat(document.getElementById('voronoiFaceOpacity').value);
            const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
            const voronoiEdgeColorInt = parseInt(voronoiEdgeColorHex.substring(1), 16);
            const useRandomColors = document.getElementById('randomVoronoiColors').checked;
            
            // Create materials using Voronoi panel settings
            const wireframeMaterial = new THREE.LineBasicMaterial({ 
                color: voronoiEdgeColorInt,
                linewidth: 1
            });
            
            const solidMaterial = new THREE.MeshPhongMaterial({ 
                color: voronoiFaceColorInt,
                opacity: opacity,
                transparent: true,
                side: THREE.DoubleSide,
                flatShading: true  // Ensure flat faces
            });
            
            switch (structureType) {
                case 'cubic_honeycomb':
                    drawCubicHoneycombStructure(divisions, step, wireframeMaterial, solidMaterial);
                    break;
                case 'tet_oct_honeycomb':
                    drawTetOctHoneycombStructure(divisions, step, wireframeMaterial, solidMaterial);
                    break;
                case 'truncated_octahedron':
                    drawTruncatedOctahedronStructure(divisions, step, wireframeMaterial, solidMaterial);
                    break;
                case 'rhombic_dodecahedron':
                    drawRhombicDodecahedronStructure(divisions, step, wireframeMaterial, solidMaterial);
                    break;
            }
        }

        function drawCubicHoneycombStructure(divisions, step, wireframeMaterial, solidMaterial) {
            const cubeSize = step * 0.8; // Slightly smaller than step to show gaps
            const useRandomColors = document.getElementById('randomVoronoiColors').checked;
            const showVoronoiEdges = document.getElementById('showVoronoi').checked;
            
            let cubeIndex = 0;
            for (let i = 0; i < divisions; i++) {
                for (let j = 0; j < divisions; j++) {
                    for (let k = 0; k < divisions; k++) {
                        const x = i * step + step/2;
                        const y = j * step + step/2;
                        const z = k * step + step/2;
                        
                        // Create cube geometry with flat faces
                        const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize, 1, 1, 1);
                        
                        // Choose material based on random color setting
                        let material;
                        if (useRandomColors) {
                            const randomColor = generateRandomColor(cubeIndex);
                            material = new THREE.MeshPhongMaterial({
                                color: randomColor,
                                opacity: solidMaterial.opacity,
                                transparent: true,
                                side: THREE.DoubleSide,
                                flatShading: true
                            });
                        } else {
                            material = solidMaterial;
                        }
                        
                        // Solid cube
                        const solidMesh = new THREE.Mesh(geometry, material);
                        solidMesh.position.set(x, y, z);
                        voronoiFacesGroup.add(solidMesh);
                        
                        // Wireframe only if Voronoi edges are enabled - use clean cube edges
                        if (showVoronoiEdges) {
                            const edgeGeometry = createPolyhedronEdges('cube', cubeSize);
                            const edgeMesh = new THREE.LineSegments(edgeGeometry, wireframeMaterial);
                            edgeMesh.position.set(x, y, z);
                            voronoiGroup.add(edgeMesh);
                        }
                        
                        cubeIndex++;
                    }
                }
            }
            
            console.log(`Drew cubic honeycomb with ${divisions}³ = ${divisions * divisions * divisions} cubes using Voronoi panel settings`);
        }

        function drawTetOctHoneycombStructure(divisions, step, wireframeMaterial, solidMaterial) {
            const size = step * 0.3;
            const useRandomColors = document.getElementById('randomVoronoiColors').checked;
            const showVoronoiEdges = document.getElementById('showVoronoi').checked;
            
            let shapeIndex = 0;
            for (let i = 0; i < divisions; i++) {
                for (let j = 0; j < divisions; j++) {
                    for (let k = 0; k < divisions; k++) {
                        const x = i * step + step/2;
                        const y = j * step + step/2;
                        const z = k * step + step/2;
                        
                        // Choose material based on random color setting
                        let tetMaterial;
                        if (useRandomColors) {
                            const randomColor = generateRandomColor(shapeIndex);
                            tetMaterial = new THREE.MeshPhongMaterial({
                                color: randomColor,
                                opacity: solidMaterial.opacity,
                                transparent: true,
                                side: THREE.DoubleSide,
                                flatShading: true
                            });
                        } else {
                            tetMaterial = solidMaterial;
                        }
                        
                        // Tetrahedron with flat faces
                        const tetGeometry = new THREE.TetrahedronGeometry(size, 0);
                        const tetMesh = new THREE.Mesh(tetGeometry, tetMaterial);
                        tetMesh.position.set(x, y, z);
                        voronoiFacesGroup.add(tetMesh);
                        
                        // Wireframe for tetrahedron
                        if (showVoronoiEdges) {
                            const tetWireframe = new THREE.WireframeGeometry(tetGeometry);
                            const tetWireframeMesh = new THREE.LineSegments(tetWireframe, wireframeMaterial);
                            tetWireframeMesh.position.set(x, y, z);
                            voronoiGroup.add(tetWireframeMesh);
                        }
                        
                        shapeIndex++;
                        
                        // Octahedron (alternating pattern)
                        if ((i + j + k) % 2 === 0) {
                            let octMaterial;
                            if (useRandomColors) {
                                const randomColor = generateRandomColor(shapeIndex);
                                octMaterial = new THREE.MeshPhongMaterial({
                                    color: randomColor,
                                    opacity: solidMaterial.opacity,
                                    transparent: true,
                                    side: THREE.DoubleSide,
                                    flatShading: true
                                });
                            } else {
                                octMaterial = solidMaterial;
                            }
                            
                            const octGeometry = new THREE.OctahedronGeometry(size * 0.8, 0);
                            const octMesh = new THREE.Mesh(octGeometry, octMaterial);
                            octMesh.position.set(x + step/4, y + step/4, z + step/4);
                            voronoiFacesGroup.add(octMesh);
                            
                            // Wireframe for octahedron
                            if (showVoronoiEdges) {
                                const octWireframe = new THREE.WireframeGeometry(octGeometry);
                                const octWireframeMesh = new THREE.LineSegments(octWireframe, wireframeMaterial);
                                octWireframeMesh.position.set(x + step/4, y + step/4, z + step/4);
                                voronoiGroup.add(octWireframeMesh);
                            }
                            
                            shapeIndex++;
                        }
                    }
                }
            }
            
            console.log(`Drew tetrahedral-octahedral honeycomb using Voronoi panel settings`);
        }

        function drawTruncatedOctahedronStructure(divisions, step, wireframeMaterial, solidMaterial) {
            const size = step * 0.4;
            const useRandomColors = document.getElementById('randomVoronoiColors').checked;
            const showVoronoiEdges = document.getElementById('showVoronoi').checked;
            
            let shapeIndex = 0;
            for (let i = 0; i < divisions; i++) {
                for (let j = 0; j < divisions; j++) {
                    for (let k = 0; k < divisions; k++) {
                        const x = i * step + step/2;
                        const y = j * step + step/2;
                        const z = k * step + step/2;
                        
                        // Choose material based on random color setting
                        let material;
                        if (useRandomColors) {
                            const randomColor = generateRandomColor(shapeIndex);
                            material = new THREE.MeshPhongMaterial({
                                color: randomColor,
                                opacity: solidMaterial.opacity,
                                transparent: true,
                                side: THREE.DoubleSide,
                                flatShading: true
                            });
                        } else {
                            material = solidMaterial;
                        }
                        
                        // Use octahedron as approximation for truncated octahedron with flat faces
                        const geometry = new THREE.OctahedronGeometry(size, 0);
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(x, y, z);
                        voronoiFacesGroup.add(mesh);
                        
                        // Wireframe only if Voronoi edges are enabled
                        if (showVoronoiEdges) {
                            const wireframeGeometry = new THREE.WireframeGeometry(geometry);
                            const wireframeMesh = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                            wireframeMesh.position.set(x, y, z);
                            voronoiGroup.add(wireframeMesh);
                        }
                        
                        shapeIndex++;
                    }
                }
            }
            
            console.log(`Drew truncated octahedron honeycomb using Voronoi panel settings`);
        }

        function drawRhombicDodecahedronStructure(divisions, step, wireframeMaterial, solidMaterial) {
            const size = step * 0.4;
            const useRandomColors = document.getElementById('randomVoronoiColors').checked;
            const showVoronoiEdges = document.getElementById('showVoronoi').checked;
            
            let shapeIndex = 0;
            for (let i = 0; i < divisions; i++) {
                for (let j = 0; j < divisions; j++) {
                    for (let k = 0; k < divisions; k++) {
                        const x = i * step + step/2;
                        const y = j * step + step/2;
                        const z = k * step + step/2;
                        
                        // Choose material based on random color setting
                        let material;
                        if (useRandomColors) {
                            const randomColor = generateRandomColor(shapeIndex);
                            material = new THREE.MeshPhongMaterial({
                                color: randomColor,
                                opacity: solidMaterial.opacity,
                                transparent: true,
                                side: THREE.DoubleSide,
                                flatShading: true
                            });
                        } else {
                            material = solidMaterial;
                        }
                        
                        // Use dodecahedron as approximation for rhombic dodecahedron with flat faces
                        const geometry = new THREE.DodecahedronGeometry(size, 0);
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(x, y, z);
                        voronoiFacesGroup.add(mesh);
                        
                        // Wireframe only if Voronoi edges are enabled
                        if (showVoronoiEdges) {
                            const wireframeGeometry = new THREE.WireframeGeometry(geometry);
                            const wireframeMesh = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                            wireframeMesh.position.set(x, y, z);
                            voronoiGroup.add(wireframeMesh);
                        }
                        
                        shapeIndex++;
                    }
                }
            }
            
            console.log(`Drew rhombic dodecahedron honeycomb using Voronoi panel settings`);
        }

        // CONTROL PANEL MANAGEMENT
        function updateControlsVisibility() {
            const pointDistribution = document.getElementById('pointDistribution').value;
            const spaceFillingType = document.getElementById('spaceFillingType').value;
            const isGeometricObject = (pointDistribution !== 'voronoi' || spaceFillingType !== 'none');
            
            // Find all Delaunay-specific controls and disable them when geometric objects are selected
            const delaunayControls = [
                'showVertices',
                'showDelaunay', 
                'showTetrahedra',
                'delaunaySize',
                'vertexColor',
                'delaunayEdgeColor',
                'delaunayEdgeWidth',
                'tetraColor',
                'tetraOpacity'
            ];
            
            delaunayControls.forEach(controlId => {
                const control = document.getElementById(controlId);
                if (control) {
                    control.disabled = isGeometricObject;
                    // Also fade the control visually
                    control.style.opacity = isGeometricObject ? '0.5' : '1.0';
                    
                    // Find the parent control group and fade the label too
                    const controlGroup = control.closest('.control-group');
                    if (controlGroup) {
                        const label = controlGroup.querySelector('label');
                        if (label) {
                            label.style.opacity = isGeometricObject ? '0.5' : '1.0';
                        }
                    }
                }
            });
            
            // Find and disable only the Delaunay Triangles / Tetrahedra section header and its controls
            // but keep the Voronoi Diagrams / Objects section fully enabled
            const delaunayHeaders = document.querySelectorAll('.section-header');
            delaunayHeaders.forEach(header => {
                if (header.textContent.includes('Delaunay Triangles') || header.textContent.includes('Tetrahedra')) {
                    header.style.opacity = isGeometricObject ? '0.5' : '1.0';
                }
                // Keep "Voronoi Diagrams / Objects" section always enabled
                if (header.textContent.includes('Voronoi Diagrams / Objects')) {
                    header.style.opacity = '1.0';
                }
            });
            
            console.log(`Controls updated: Delaunay controls ${isGeometricObject ? 'disabled' : 'enabled'} for ${pointDistribution}`);
        }

        // UNIFIED POINT GENERATION FUNCTION
        function generatePoints() {
            const numPoints = parseInt(document.getElementById('numPoints').value);
            const minDist = parseFloat(document.getElementById('minDistance').value);
            const usePoisson = document.getElementById('poissonSampling').checked;
            const pointDistribution = document.getElementById('pointDistribution').value;
            const spaceFillingType = document.getElementById('spaceFillingType').value;
            const scale = parseFloat(document.getElementById('geometricScale').value);
            const divisions = parseInt(document.getElementById('honeycombDivisions').value);
            
            console.log(`Generating points: distribution=${pointDistribution}, spaceFilling=${spaceFillingType}, scale=${scale}, divisions=${divisions}`);
            
            // Handle space-filling types first (they override individual shapes)
            if (spaceFillingType !== 'none') {
                switch (spaceFillingType) {
                    case 'cubic_honeycomb':
                        return generateCubicHoneycomb(divisions);
                    case 'tet_oct_honeycomb':
                        return generateTetOctHoneycomb(divisions);
                    case 'truncated_octahedron':
                        return generateTruncatedOctahedron(divisions);
                    case 'rhombic_dodecahedron':
                        return generateRhombicDodecahedron(divisions);
                    default:
                        console.warn(`Unknown space-filling type: ${spaceFillingType}`);
                        return generatePoissonPoints(numPoints, minDist);
                }
            }
            
            // Handle individual geometric shapes
            switch (pointDistribution) {
                case 'tetrahedron':
                    return generateTetrahedronPoints(scale);
                case 'cube':
                    return generateCubePoints(scale);
                case 'octahedron':
                    return generateOctahedronPoints(scale);
                case 'dodecahedron':
                    return generateDodecahedronPoints(scale);
                case 'icosahedron':
                    return generateIcosahedronPoints(scale);
                case 'voronoi':
                default:
                    // Use Poisson sampling if enabled, otherwise random
                    return usePoisson ? 
                        generatePoissonPoints(numPoints, minDist) : 
                        generateWellDistributedPoints(numPoints, minDist);
            }
        }

        // NEW: Simple line functions for better performance (width parameter kept for compatibility)
        function createDelaunayEdgesThick(computation, width, material) {
            const delaunayEdgeSet = new Set();
            const positions = [];

            for (const tet of computation.tetrahedra) {
                const edges = [
                    [tet[0], tet[1]], [tet[0], tet[2]], [tet[0], tet[3]], 
                    [tet[1], tet[2]], [tet[1], tet[3]], [tet[2], tet[3]]
                ];
                
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (!delaunayEdgeSet.has(key)) {
                        delaunayEdgeSet.add(key);
                        
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.pointsArray[b];
                        
                        if (computation.isPeriodic) {
                            const p2_mic = getMinimumImage(p1, p2);
                            positions.push(p1[0], p1[1], p1[2]);
                            positions.push(p2_mic[0], p2_mic[1], p2_mic[2]);
                        } else {
                            positions.push(p1[0], p1[1], p1[2]);
                            positions.push(p2[0], p2[1], p2[2]);
                        }
                    }
                }
            }

            if (positions.length === 0) return;

            const geometry = new LineGeometry();
            geometry.setPositions(positions);

            const lineMaterial = new LineMaterial({
                color: material.color.getHex(),
                linewidth: width,
                resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),
                linecap: 'square',
                linejoin: 'miter'
            });

            const line = new Line2(geometry, lineMaterial);
            line.computeLineDistances();
            delaunayGroup.add(line);
        }

        function createVoronoiEdgesThick(computation, width, material) {
            if (computation.voronoiEdges.length === 0) return;
            
            const positions = [];
            for (const edge of computation.voronoiEdges) {
                const p1 = edge.start;
                const p2 = edge.end;
                
                if (computation.isPeriodic) {
                    const p2_mic = getMinimumImage(p1, p2);
                    positions.push(p1[0], p1[1], p1[2]);
                    positions.push(p2_mic[0], p2_mic[1], p2_mic[2]);
                } else {
                    positions.push(p1[0], p1[1], p1[2]);
                    positions.push(p2[0], p2[1], p2[2]);
                }
            }

            const geometry = new LineGeometry();
            geometry.setPositions(positions);

            const lineMaterial = new LineMaterial({
                color: material.color.getHex(),
                linewidth: width,
                resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),
                linecap: 'square',
                linejoin: 'miter'
            });

            const line = new Line2(geometry, lineMaterial);
            line.computeLineDistances();
            voronoiGroup.add(line);
        }

        // NEW: MIC-based edge drawing function (Phase 2 implementation)
        function createDelaunayEdgesMIC(computation) {
            const points = [];
            const delaunayEdgeSet = new Set();
            
            // Extract unique edges from tetrahedra
            for (const tet of computation.tetrahedra) {
                const edges = [
                    [tet[0], tet[1]], [tet[0], tet[2]], [tet[0], tet[3]], 
                    [tet[1], tet[2]], [tet[1], tet[3]], [tet[2], tet[3]]
                ];
                
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (!delaunayEdgeSet.has(key)) {
                        delaunayEdgeSet.add(key);
                        
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.pointsArray[b];
                        
                        if (computation.isPeriodic) {
                            const p2_mic = getMinimumImage(p1, p2);
                            points.push(p1[0], p1[1], p1[2]);
                            points.push(p2_mic[0], p2_mic[1], p2_mic[2]);
                        } else {
                            points.push(p1[0], p1[1], p1[2]);
                            points.push(p2[0], p2[1], p2[2]);
                        }
                    }
                }
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            return geometry;
        }

        // NEW: Enhanced Voronoi edge drawing with MIC
        function createVoronoiEdgesMIC(computation) {
            if (computation.voronoiEdges.length === 0) return null;
            
            const points = [];
            for (const edge of computation.voronoiEdges) {
                const p1 = edge.start;
                const p2 = edge.end;
                
                if (computation.isPeriodic) {
                    const p2_mic = getMinimumImage(p1, p2);
                    points.push(p1[0], p1[1], p1[2]);
                    points.push(p2_mic[0], p2_mic[1], p2_mic[2]);
                } else {
                    points.push(p1[0], p1[1], p1[2]);
                    points.push(p2[0], p2[1], p2[2]);
                }
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            return geometry;
        }

        // NEW: Generate stable random colors for Voronoi cells
        function generateRandomColor(index) {
            // Use index as seed for consistent colors across redraws
            const hue = (index * 137.508) % 360; // Golden angle for good distribution
            const saturation = 70 + (index * 17) % 30; // 70-100% saturation
            const lightness = 45 + (index * 13) % 20;  // 45-65% lightness
            
            // Convert HSL to RGB
            const h = hue / 360;
            const s = saturation / 100;
            const l = lightness / 100;
            
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return new THREE.Color(r, g, b);
        }

        // NEW: Ghost Cell Tiling (Phase 3 implementation)
        function createGhostCellTiling() {
            ghostCellsGroup.children.forEach(child => {
                if (child.isGroup) {
                    child.children.forEach(c => {
                        if (c.geometry) c.geometry.dispose();
                        if (c.material) c.material.dispose();
                    });
                }
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            ghostCellsGroup.clear();
            
            if (!computation || !document.getElementById('showGhostCells').checked) {
                return;
            }
            
            console.log("Creating ghost cell tiling...");
            
            // Define the 26 neighboring cell positions (excluding center at [0,0,0])
            const ghostOffsets = [];
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        if (x !== 0 || y !== 0 || z !== 0) { // Skip center cell
                            ghostOffsets.push([x, y, z]);
                        }
                    }
                }
            }
            
            // Semi-transparent materials for ghost cells
            const delaunayEdgeColorHex = document.getElementById('delaunayEdgeColor').value;
            const delaunayEdgeColorInt = parseInt(delaunayEdgeColorHex.substring(1), 16);
            const ghostDelaunayMaterial = new THREE.LineBasicMaterial({ 
                color: delaunayEdgeColorInt, 
                opacity: 0.3, 
                transparent: true 
            });
            
            const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
            const voronoiEdgeColorInt = parseInt(voronoiEdgeColorHex.substring(1), 16);
            const ghostVoronoiMaterial = new THREE.LineBasicMaterial({ 
                color: voronoiEdgeColorInt, 
                opacity: 0.2, 
                transparent: true
            });
            
            const vertexColorHex = document.getElementById('vertexColor').value;
            const vertexColorInt = parseInt(vertexColorHex.substring(1), 16);
            const ghostVertexMaterial = new THREE.MeshPhongMaterial({ 
                color: vertexColorInt, 
                opacity: 0.4, 
                transparent: true 
            });
            
            // Create ghost geometries
            const delaunayGeometry = createDelaunayEdgesMIC(computation);
            const voronoiGeometry = createVoronoiEdgesMIC(computation);
            
            // Create ghost cells for each offset
            for (const [offsetX, offsetY, offsetZ] of ghostOffsets) {
                const ghostGroup = new THREE.Group();
                ghostGroup.position.set(offsetX, offsetY, offsetZ);
                
                // Add Delaunay edges
                if (delaunayGeometry && document.getElementById('showDelaunay').checked) {
                    const ghostDelaunayLines = new THREE.LineSegments(
                        delaunayGeometry.clone(), 
                        ghostDelaunayMaterial
                    );
                    ghostGroup.add(ghostDelaunayLines);
                }
                
                // Add Voronoi edges
                if (voronoiGeometry && document.getElementById('showVoronoi').checked) {
                    const ghostVoronoiLines = new THREE.LineSegments(
                        voronoiGeometry.clone(), 
                        ghostVoronoiMaterial
                    );
                    ghostGroup.add(ghostVoronoiLines);
                }
                
                // Add Voronoi faces with same random coloring as main cell
                if (document.getElementById('showVoronoiFaces').checked && computation.tetrahedra.length > 0) {
                    const useRandomColors = document.getElementById('randomVoronoiColors').checked;
                    const opacity = parseFloat(document.getElementById('voronoiFaceOpacity').value) * 0.3; // More transparent for ghost
                    
                    // Create ghost Voronoi cells
                    const cells = new Map();
                    computation.tetrahedra.forEach((tet, index) => {
                        const barycenter = computation.barycenters[index];
                        if (!barycenter) return;

                        tet.forEach(vertexIndex => {
                            if (!cells.has(vertexIndex)) {
                                cells.set(vertexIndex, []);
                            }
                            cells.get(vertexIndex).push(new THREE.Vector3(...barycenter));
                        });
                    });

                    cells.forEach((cellVertices, vertexIndex) => {
                        if (cellVertices.length < 4) return;

                        const geometry = new ConvexGeometry(cellVertices);
                        
                        let material;
                        if (useRandomColors) {
                            const randomColor = generateRandomColor(vertexIndex);
                            material = new THREE.MeshPhongMaterial({
                                color: randomColor,
                                opacity: opacity,
                                transparent: true,
                                side: THREE.DoubleSide,
                                depthWrite: false
                            });
                        } else {
                            const voronoiFaceColorHex = document.getElementById('voronoiFaceColor').value;
                            const voronoiFaceColorInt = parseInt(voronoiFaceColorHex.substring(1), 16);
                            material = new THREE.MeshPhongMaterial({
                                color: voronoiFaceColorInt,
                                opacity: opacity,
                                transparent: true,
                                side: THREE.DoubleSide,
                                depthWrite: false
                            });
                        }
                        
                        const mesh = new THREE.Mesh(geometry, material);
                        ghostGroup.add(mesh);
                    });
                }
                
                // Add vertices
                if (document.getElementById('showVertices').checked) {
                    const vertexSize = parseFloat(document.getElementById('delaunaySize').value);
                    const sphereGeometry = new THREE.SphereGeometry(vertexSize, 8, 8);
                    
                    for (const point of computation.pointsArray) {
                        const sphere = new THREE.Mesh(sphereGeometry, ghostVertexMaterial);
                        sphere.position.set(point[0], point[1], point[2]);
                        ghostGroup.add(sphere);
                    }
                }
                
                ghostCellsGroup.add(ghostGroup);
            }
            
            console.log(`Created ${ghostOffsets.length} ghost cells`);
        }

        // Legacy boundary clipping approach (for comparison)
        function drawMeshesLegacy(computation, delaunayMaterial, voronoiMaterial) {
            const delaunayPeriodicMaterial = new THREE.LineBasicMaterial({ 
                color: delaunayMaterial.color, 
                opacity: 0.6, 
                transparent: true 
            });
            const voronoiPeriodicMaterial = new THREE.LineBasicMaterial({ 
                color: voronoiMaterial.color, 
                opacity: 0.8, 
                transparent: true 
            });
            
            let periodicEdgeCount = 0;
            let regularEdgeCount = 0;
            
            // --- Draw Delaunay Edges with Legacy Clipping ---
            const delaunayEdgeSet = new Set();
            for (const tet of computation.tetrahedra) {
                const edges = [
                    [tet[0], tet[1]], [tet[0], tet[2]], [tet[0], tet[3]], 
                    [tet[1], tet[2]], [tet[1], tet[3]], [tet[2], tet[3]]
                ];
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (!delaunayEdgeSet.has(key)) {
                        delaunayEdgeSet.add(key);
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.pointsArray[b];
                        
                        if (computation.isPeriodic) {
                            const p2min = getMinimumImage(p1, p2);
                            const isPeriodic = (p2min[0] !== p2[0] || p2min[1] !== p2[1] || p2min[2] !== p2[2]);
                            
                            if (isPeriodic) {
                                periodicEdgeCount++;
                                // OLD: Boundary clipping approach
                                for (let dim = 0; dim < 3; dim++) {
                                    const diff = p2[dim] - p1[dim];
                                    if (Math.abs(diff) > 0.5) {
                                        const t = diff > 0 ? (1.0 - p1[dim]) / diff : (0.0 - p1[dim]) / diff;
                                        const tClamped = Math.max(0.001, Math.min(0.999, t));
                                        
                                        const midPoint = [
                                            p1[0] + tClamped * (p2[0] - p1[0]),
                                            p1[1] + tClamped * (p2[1] - p1[1]),
                                            p1[2] + tClamped * (p2[2] - p1[2])
                                        ];
                                        midPoint[dim] = diff > 0 ? 0.999 : 0.001;
                                        
                                        // Draw first segment to boundary
                                        const geom1 = new THREE.BufferGeometry().setFromPoints([
                                            new THREE.Vector3(...p1),
                                            new THREE.Vector3(...midPoint)
                                        ]);
                                        delaunayGroup.add(new THREE.Line(geom1, delaunayPeriodicMaterial));
                                        
                                        // Draw second segment from opposite boundary
                                        const oppositePoint = [...midPoint];
                                        oppositePoint[dim] = diff > 0 ? 0.001 : 0.999;
                                        const geom2 = new THREE.BufferGeometry().setFromPoints([
                                            new THREE.Vector3(...oppositePoint),
                                            new THREE.Vector3(...p2)
                                        ]);
                                        delaunayGroup.add(new THREE.Line(geom2, delaunayPeriodicMaterial));
                                        break;
                                    }
                                }
                            } else {
                                regularEdgeCount++;
                                const lineGeom = new THREE.BufferGeometry().setFromPoints([
                                    new THREE.Vector3(...p1), new THREE.Vector3(...p2)
                                ]);
                                delaunayGroup.add(new THREE.Line(lineGeom, delaunayMaterial));
                            }
                        } else {
                            const lineGeom = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(...p1), new THREE.Vector3(...p2)
                            ]);
                            delaunayGroup.add(new THREE.Line(lineGeom, delaunayMaterial));
                        }
                    }
                }
            }
            
            // --- Draw Voronoi Edges with Legacy Clipping ---
            for (const edge of computation.voronoiEdges) {
                const p1 = edge.start;
                const p2 = edge.end;
                
                if (computation.isPeriodic) {
                    const p2min = getMinimumImage(p1, p2);
                    const isPeriodic = (p2min[0] !== p2[0] || p2min[1] !== p2[1] || p2min[2] !== p2[2]);
                    
                    if (isPeriodic) {
                        for (let dim = 0; dim < 3; dim++) {
                            const diff = p2[dim] - p1[dim];
                            if (Math.abs(diff) > 0.5) {
                                const t = diff > 0 ? (1.0 - p1[dim]) / diff : (0.0 - p1[dim]) / diff;
                                const tClamped = Math.max(0.001, Math.min(0.999, t));
                                
                                const midPoint = [
                                    p1[0] + tClamped * (p2[0] - p1[0]),
                                    p1[1] + tClamped * (p2[1] - p1[1]),
                                    p1[2] + tClamped * (p2[2] - p1[2])
                                ];
                                midPoint[dim] = diff > 0 ? 0.999 : 0.001;
                                
                                const geom1 = new THREE.BufferGeometry().setFromPoints([
                                    new THREE.Vector3(...p1),
                                    new THREE.Vector3(...midPoint)
                                ]);
                                voronoiGroup.add(new THREE.Line(geom1, voronoiPeriodicMaterial));
                                
                                const oppositePoint = [...midPoint];
                                oppositePoint[dim] = diff > 0 ? 0.001 : 0.999;
                                const geom2 = new THREE.BufferGeometry().setFromPoints([
                                    new THREE.Vector3(...oppositePoint),
                                    new THREE.Vector3(...p2)
                                ]);
                                voronoiGroup.add(new THREE.Line(geom2, voronoiPeriodicMaterial));
                                break;
                            }
                        }
                    } else {
                        const lineGeom = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(...p1), new THREE.Vector3(...p2)
                        ]);
                        voronoiGroup.add(new THREE.Line(lineGeom, voronoiMaterial));
                    }
                } else {
                    const lineGeom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(...p1), new THREE.Vector3(...p2)
                    ]);
                    voronoiGroup.add(new THREE.Line(lineGeom, voronoiMaterial));
                }
            }
            
            console.log(`Legacy: Drew ${periodicEdgeCount} periodic edges (clipped), ${regularEdgeCount} regular edges`);
        }

        // Visualize vertices
        function drawVertices(computation) {
            // Dispose of old geometries and materials
            verticesGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            verticesGroup.clear();
            
            const vertexSize = parseFloat(document.getElementById('delaunaySize').value);
            const vertexColorHex = document.getElementById('vertexColor').value;
            const vertexColorInt = parseInt(vertexColorHex.substring(1), 16);
            
            const geometry = new THREE.SphereGeometry(vertexSize, 16, 16);
            const material = new THREE.MeshPhongMaterial({ color: vertexColorInt });
            
            for (const point of computation.pointsArray) {
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(point[0], point[1], point[2]);
                verticesGroup.add(sphere);
            }
        }
        
        // Visualize Delaunay edges
        function drawDelaunay(computation) {
            delaunayGroup.clear();
            
            if (computation.tetrahedra.length === 0) return;
            
            const edgeSet = new Set();
            const material = new THREE.LineBasicMaterial({ color: 0x0066ff });
            const periodicMaterial = new THREE.LineBasicMaterial({ 
                color: 0x0099ff
            });
            
            // Extract unique edges from tetrahedra
            for (const tet of computation.tetrahedra) {
                const edges = [
                    [tet[0], tet[1]], [tet[0], tet[2]], [tet[0], tet[3]],
                    [tet[1], tet[2]], [tet[1], tet[3]], [tet[2], tet[3]]
                ];
                
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (!edgeSet.has(key)) {
                        edgeSet.add(key);
                        
                        // Get vertex positions
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.pointsArray[b];
                        
                        // Check if edge crosses periodic boundary
                        const isPeriodic = computation._isPeriodicEdge(p1, p2);
                        
                        const geometry = new THREE.BufferGeometry();
                        const positions = new Float32Array([
                            p1[0], p1[1], p1[2],
                            p2[0], p2[1], p2[2]
                        ]);
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        
                        const line = new THREE.Line(
                            geometry, 
                            isPeriodic ? periodicMaterial : material
                        );
                        delaunayGroup.add(line);
                    }
                }
            }
        }
        
        // Visualize Voronoi edges
        function drawVoronoi(computation) {
            voronoiGroup.clear();
            
            if (computation.voronoiEdges.length === 0) return;
            
            const voronoiColorHex = document.getElementById('voronoiColor').value;
            const voronoiColorInt = parseInt(voronoiColorHex.substring(1), 16);
            
            const material = new THREE.LineBasicMaterial({ 
                color: voronoiColorInt
            });
            const periodicMaterial = new THREE.LineBasicMaterial({ 
                color: voronoiColorInt,
                opacity: 0.8,
                transparent: true
            });
            
            for (const edge of computation.voronoiEdges) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array([
                    edge.start[0], edge.start[1], edge.start[2],
                    edge.end[0], edge.end[1], edge.end[2]
                ]);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const line = new THREE.Line(
                    geometry, 
                    edge.isPeriodic ? periodicMaterial : material
                );
                voronoiGroup.add(line);
            }
            
            // Also draw the barycenters as small spheres
            const voronoiVertexSize = parseFloat(document.getElementById('voronoiSize').value);
            const sphereGeometry = new THREE.SphereGeometry(voronoiVertexSize, 8, 8);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: voronoiColorInt,
                emissive: voronoiColorInt,
                emissiveIntensity: 0.3
            });
            
            for (const center of computation.barycenters) {
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(center[0], center[1], center[2]);
                voronoiGroup.add(sphere);
            }
        }
        
        // Draw Voronoi faces with optional random colors and MIC for periodic boundaries
        function drawVoronoiFaces(computation) {
            voronoiFacesGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            voronoiFacesGroup.clear();
            
            if (!computation.tetrahedra.length || !computation.barycenters.length) return;
            
            const useRandomColors = document.getElementById('randomVoronoiColors').checked;
            const voronoiFaceColorHex = document.getElementById('voronoiFaceColor').value;
            const voronoiFaceColorInt = parseInt(voronoiFaceColorHex.substring(1), 16);
            const opacity = parseFloat(document.getElementById('voronoiFaceOpacity').value);
            
            // Default material for non-random mode
            const defaultMaterial = new THREE.MeshPhongMaterial({
                color: voronoiFaceColorInt,
                opacity: opacity,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false // Important for transparent objects
            });
            
            // Map each original vertex to the barycenters of tetrahedra that contain it
            const cells = new Map();
            computation.tetrahedra.forEach((tet, index) => {
                const barycenter = computation.barycenters[index];
                if (!barycenter) return;

                tet.forEach(vertexIndex => {
                    if (!cells.has(vertexIndex)) {
                        cells.set(vertexIndex, []);
                    }
                    cells.get(vertexIndex).push(barycenter); // Store as array, not THREE.Vector3 yet
                });
            });

            // For each cell, compute the convex hull with MIC correction for periodic boundaries
            let cellIndex = 0;
            cells.forEach((cellBarycenters, vertexIndex) => {
                if (cellBarycenters.length < 4) return; // Need at least 4 points for a 3D shape

                let correctedVertices;
                
                if (computation.isPeriodic && cellBarycenters.length > 0) {
                    // Apply MIC: Use first barycenter as reference, correct others to same periodic image
                    const reference = cellBarycenters[0];
                    correctedVertices = cellBarycenters.map(barycenter => {
                        if (barycenter === reference) {
                            return new THREE.Vector3(...reference);
                        }
                        
                        // Apply MIC to bring barycenter to same periodic image as reference
                        const corrected = getMinimumImage(reference, barycenter);
                        return new THREE.Vector3(...corrected);
                    });
                } else {
                    // Non-periodic: use barycenters as-is
                    correctedVertices = cellBarycenters.map(barycenter => 
                        new THREE.Vector3(...barycenter)
                    );
                }

                try {
                    // Create a convex geometry from the corrected vertices of the Voronoi cell
                    const geometry = new ConvexGeometry(correctedVertices);
                    
                    // Choose material based on random color setting
                    let material;
                    if (useRandomColors) {
                        const randomColor = generateRandomColor(vertexIndex);
                        material = new THREE.MeshPhongMaterial({
                            color: randomColor,
                            opacity: opacity,
                            transparent: true,
                            side: THREE.DoubleSide,
                            depthWrite: false
                        });
                    } else {
                        material = defaultMaterial;
                    }
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    voronoiFacesGroup.add(mesh);
                    cellIndex++;
                } catch (error) {
                    // Skip cells that can't form valid convex geometry
                    console.warn(`Skipped Voronoi cell ${vertexIndex}: ${error.message}`);
                }
            });
            
            console.log(`Drew ${cellIndex} Voronoi cells ${useRandomColors ? 'with random colors' : 'with uniform color'} ${computation.isPeriodic ? '(MIC corrected)' : ''}`);
        }
        
        // NEW: Unified mesh drawing function with MIC toggle
        function drawMeshes(computation) {
            // Dispose of old geometries and materials to prevent memory leaks
            delaunayGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            voronoiGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            voronoiFacesGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });

            delaunayGroup.clear();
            voronoiGroup.clear();
            voronoiFacesGroup.clear();

            const useMIC = document.getElementById('useMIC').checked;
            
            // Toggle UI based on MIC mode
            document.getElementById('delaunayEdgeWidth').disabled = !useMIC;
            document.getElementById('voronoiEdgeWidth').disabled = !useMIC;

            if (useMIC) {
                // --- Draw using Thick Line (MIC) mode ---
                const delaunayEdgeColorHex = document.getElementById('delaunayEdgeColor').value;
                const delaunayEdgeColorInt = parseInt(delaunayEdgeColorHex.substring(1), 16);
                const delaunayEdgeWidth = parseFloat(document.getElementById('delaunayEdgeWidth').value);
                const delaunayMaterial = new THREE.LineBasicMaterial({ color: delaunayEdgeColorInt });
                createDelaunayEdgesThick(computation, delaunayEdgeWidth, delaunayMaterial);

                const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
                const voronoiEdgeColorInt = parseInt(voronoiEdgeColorHex.substring(1), 16);
                const voronoiEdgeWidth = parseFloat(document.getElementById('voronoiEdgeWidth').value);
                const voronoiMaterial = new THREE.LineBasicMaterial({ color: voronoiEdgeColorInt });
                createVoronoiEdgesThick(computation, voronoiEdgeWidth, voronoiMaterial);

            } else {
                // --- Draw using Normal, Thin Line mode ---
                const delaunayGeom = createDelaunayEdgesMIC(computation);
                if (delaunayGeom) {
                    const delaunayMaterial = new THREE.LineBasicMaterial({ color: document.getElementById('delaunayEdgeColor').value });
                    delaunayGroup.add(new THREE.LineSegments(delaunayGeom, delaunayMaterial));
                }

                const voronoiGeom = createVoronoiEdgesMIC(computation);
                if (voronoiGeom) {
                    const voronoiMaterial = new THREE.LineBasicMaterial({ color: document.getElementById('voronoiEdgeColor').value });
                    voronoiGroup.add(new THREE.LineSegments(voronoiGeom, voronoiMaterial));
                }
            }
            
            // Voronoi vertices are drawn in both modes
            const voronoiVertexSize = parseFloat(document.getElementById('voronoiSize').value);
            const voronoiVertexColorHex = document.getElementById('voronoiVertexColor').value;
            const voronoiVertexColorInt = parseInt(voronoiVertexColorHex.substring(1), 16);
            const sphereGeometry = new THREE.SphereGeometry(voronoiVertexSize, 8, 8);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: voronoiVertexColorInt,
                emissive: voronoiVertexColorInt,
                emissiveIntensity: 0.3
            });
            
            for (const center of computation.barycenters) {
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(center[0], center[1], center[2]);
                voronoiGroup.add(sphere);
            }
        }
        
        // Visualize tetrahedra
        function drawTetrahedra(computation) {
            tetrahedraGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            tetrahedraGroup.clear();
            
            if (computation.tetrahedra.length === 0) return;
            
            const tetraColorHex = document.getElementById('tetraColor').value;
            const tetraColorInt = parseInt(tetraColorHex.substring(1), 16);
            const opacity = parseFloat(document.getElementById('tetraOpacity').value);
            
            const material = new THREE.MeshPhongMaterial({
                color: tetraColorInt,
                opacity: opacity,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            for (const tet of computation.tetrahedra) {
                const vertices = tet.map(i => computation.pointsArray[i]);
                
                // Create tetrahedron faces
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                
                // Face indices for tetrahedron
                const faces = [
                    [0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]
                ];
                
                for (const face of faces) {
                    for (const idx of face) {
                        positions.push(vertices[idx][0], vertices[idx][1], vertices[idx][2]);
                    }
                }
                
                geometry.setAttribute('position', 
                    new THREE.BufferAttribute(new Float32Array(positions), 3)
                );
                geometry.computeVertexNormals();
                
                const mesh = new THREE.Mesh(geometry, material);
                tetrahedraGroup.add(mesh);
            }
        }
        
        // Compute Delaunay-Voronoi
        async function computeDelaunayVoronoi() {
            if (!Module) return;
            
            // Add a small delay for live updates to prevent crashes
            if (document.getElementById('liveUpdate').checked && parseFloat(document.getElementById('motionSpeed').value) > 0) {
                await new Promise(resolve => setTimeout(resolve, 33)); // ~30 FPS
            }

            // Check if we're in geometric object mode
            const pointDistribution = document.getElementById('pointDistribution').value;
            const spaceFillingType = document.getElementById('spaceFillingType').value;
            const isGeometricObject = (pointDistribution !== 'voronoi' || spaceFillingType !== 'none');
            
            if (isGeometricObject) {
                // For geometric objects, skip Delaunay computation and just draw the shapes
                setStatus('Drawing geometric objects...', false);
                
                // Clear all visualization groups
                verticesGroup.clear();
                delaunayGroup.clear();
                tetrahedraGroup.clear();
                voronoiGroup.clear();
                voronoiFacesGroup.clear();
                
                // Draw only the geometric shapes
                drawGeometricShapes();
                
                // Update status
                const shapeType = spaceFillingType !== 'none' ? spaceFillingType : pointDistribution;
                setStatus(`${shapeType} object displayed`, true);
                
                // Clear computation reference since we're not using Delaunay
                computation = null;
                
                return;
            }

            // Normal Voronoi mode - run full Delaunay computation
            // Diagnostic check for corrupt input data
            console.log("--- New Computation Triggered ---");
            console.log(`Checking ${currentPoints.length} points before sending to WASM.`);
            let outliersFound = 0;
            for (const p of currentPoints) {
                if (!p || p.length !== 3 || p[0] < 0 || p[0] > 1 || p[1] < 0 || p[1] > 1 || p[2] < 0 || p[2] > 1) {
                    console.error("🔴 OUTLIER DETECTED! This point is outside the [0, 1] unit cube and will corrupt the periodic triangulation:", p);
                    outliersFound++;
                }
            }
            if (outliersFound > 0) {
                console.error(`Found ${outliersFound} outlier points. Halting computation.`);
                setStatus(`Error: Found ${outliersFound} outlier points.`, false);
                return; // Stop execution if data is bad
            }
            console.log("✅ Point data is clean. Proceeding with computation...");
            
            const isPeriodic = document.getElementById('periodicMode').checked;
            
            setStatus('Computing...', false);
            
            try {
                // Create computation instance
                computation = new DelaunayComputation(currentPoints, isPeriodic);
                
                // Run the computation
                await computation.compute(Module);
                
                // Get statistics
                const stats = computation.getStats();
                setStatus(`Success! ${stats.numTetrahedra} tetrahedra, ${stats.numVoronoiEdges} Voronoi edges`, true);
                
                // Update visualization
                drawVertices(computation);
                drawMeshes(computation);
                drawTetrahedra(computation);
                drawVoronoiFaces(computation);
                
                // NEW: Create ghost cell tiling
                createGhostCellTiling();
                
                updateStats();
                
            } catch (error) {
                setStatus(`Error: ${error.message}`, false);
                console.error(error);
            }
        }
        
        // Update statistics
        function updateStats() {
            if (!computation) return;
            
            const stats = computation.getStats();
            const mode = stats.isPeriodic ? 'Periodic' : 'Non-periodic';
            const statusMessage = `${mode} | ${stats.numPoints} points | ${stats.numTetrahedra} tetrahedra | ${stats.numVoronoiEdges} Voronoi edges`;
            setStatus(statusMessage, true);
        }
        
        // Set status message
        function setStatus(message, isSuccess) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${isSuccess ? 'success' : 'error'}`;
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            frameCount++;

            const motionSpeed = parseFloat(document.getElementById('motionSpeed').value);
            if (motionSpeed > 0) {
                const wander = 0.1 - parseFloat(document.getElementById('motionWander').value);

                // Update point positions based on velocity
                for (let i = 0; i < currentPoints.length; i++) {
                    // Update velocity with wander
                    velocities[i][0] += (Math.random() - 0.5) * wander;
                    velocities[i][1] += (Math.random() - 0.5) * wander;
                    velocities[i][2] += (Math.random() - 0.5) * wander;

                    // Normalize and scale velocity
                    const speed = Math.sqrt(velocities[i][0]**2 + velocities[i][1]**2 + velocities[i][2]**2);
                    if (speed > 0) {
                        velocities[i][0] = (velocities[i][0] / speed) * motionSpeed;
                        velocities[i][1] = (velocities[i][1] / speed) * motionSpeed;
                        velocities[i][2] = (velocities[i][2] / speed) * motionSpeed;
                    }

                    // Update position
                    currentPoints[i][0] += velocities[i][0];
                    currentPoints[i][1] += velocities[i][1];
                    currentPoints[i][2] += velocities[i][2];

                    // Wrap points for periodic effect
                    currentPoints[i][0] = (currentPoints[i][0] + 1) % 1;
                    currentPoints[i][1] = (currentPoints[i][1] + 1) % 1;
                    currentPoints[i][2] = (currentPoints[i][2] + 1) % 1;
                }
                
                // If live update is enabled, recompute based on frequency
                if (document.getElementById('liveUpdate').checked) {
                    const updateFrequency = parseInt(document.getElementById('updateFrequency').value);
                    if (frameCount % updateFrequency === 0) {
                        computeDelaunayVoronoi();
                    }
                } else {
                    drawVertices(computation);
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }
        
        // Initialize everything
        window.PeriodicDelaunayModule().then(module => {
            Module = module;
            setStatus('Module loaded', true);
            
            initThree();
            
            // Generate initial points using unified function
            currentPoints = generatePoints();

            // Initialize velocities
            velocities = currentPoints.map(() => [(Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)]);
            
            // Set initial control states
            updateControlsVisibility();
            
            computeDelaunayVoronoi();
            
            // Set up event listeners
            document.getElementById('showVertices').addEventListener('change', (e) => {
                verticesGroup.visible = e.target.checked;
            });
            
            document.getElementById('showDelaunay').addEventListener('change', (e) => {
                delaunayGroup.visible = e.target.checked;
            });
            
            document.getElementById('showVoronoi').addEventListener('change', (e) => {
                voronoiGroup.visible = e.target.checked;
            });
            
            document.getElementById('showTetrahedra').addEventListener('change', (e) => {
                tetrahedraGroup.visible = e.target.checked;
            });
            
            document.getElementById('showBoundary').addEventListener('change', (e) => {
                boundaryGroup.visible = e.target.checked;
            });

            document.getElementById('voronoiFaceColor').addEventListener('change', () => {
                const pointDistribution = document.getElementById('pointDistribution').value;
                const spaceFillingType = document.getElementById('spaceFillingType').value;
                
                console.log(`voronoiFaceColor changed: pointDistribution=${pointDistribution}, spaceFillingType=${spaceFillingType}`);
                
                if (pointDistribution !== 'voronoi' || spaceFillingType !== 'none') {
                    console.log('Calling drawGeometricShapes()');
                    drawGeometricShapes(); // Update geometric shapes with new color
                } else {
                    console.log('Calling drawVoronoiFaces()');
                    drawVoronoiFaces(computation);
                }
                createGhostCellTiling(); // Also update ghost cells
            });
            
            document.getElementById('voronoiFaceOpacity').addEventListener('change', () => {
                const pointDistribution = document.getElementById('pointDistribution').value;
                const spaceFillingType = document.getElementById('spaceFillingType').value;
                
                if (pointDistribution !== 'voronoi' || spaceFillingType !== 'none') {
                    drawGeometricShapes(); // Update geometric shapes with new opacity
                } else {
                    drawVoronoiFaces(computation);
                }
                createGhostCellTiling(); // Also update ghost cells
            });
            
            document.getElementById('showVoronoiFaces').addEventListener('change', (e) => {
                voronoiFacesGroup.visible = e.target.checked;
            });
            
            document.getElementById('randomVoronoiColors').addEventListener('change', () => {
                const pointDistribution = document.getElementById('pointDistribution').value;
                const spaceFillingType = document.getElementById('spaceFillingType').value;
                
                if (pointDistribution !== 'voronoi' || spaceFillingType !== 'none') {
                    drawGeometricShapes(); // Update geometric shapes with random colors
                } else {
                    drawVoronoiFaces(computation);
                }
                createGhostCellTiling(); // Also update ghost cells
            });
            
            // Also update geometric shapes when Voronoi edge settings change
            document.getElementById('voronoiEdgeColor').addEventListener('change', () => {
                const pointDistribution = document.getElementById('pointDistribution').value;
                const spaceFillingType = document.getElementById('spaceFillingType').value;
                
                if (pointDistribution !== 'voronoi' || spaceFillingType !== 'none') {
                    drawGeometricShapes(); // Update geometric shapes with new edge color
                }
            });
            
            document.getElementById('showVoronoi').addEventListener('change', () => {
                const pointDistribution = document.getElementById('pointDistribution').value;
                const spaceFillingType = document.getElementById('spaceFillingType').value;
                
                if (pointDistribution !== 'voronoi' || spaceFillingType !== 'none') {
                    drawGeometricShapes(); // Update geometric shapes wireframe visibility
                }
            });
            
            document.getElementById('regenerate').addEventListener('click', () => {
                currentPoints = generatePoints();
                velocities = currentPoints.map(() => [(Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)]);
                computeDelaunayVoronoi();
            });
            
            // Update controls when Poisson setting changes (affects Voronoi mode)
            document.getElementById('poissonSampling').addEventListener('change', () => {
                const pointDistribution = document.getElementById('pointDistribution').value;
                if (pointDistribution === 'voronoi') {
                    currentPoints = generatePoints();
                    velocities = currentPoints.map(() => [(Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)]);
                    computeDelaunayVoronoi();
                }
            });
            
            document.getElementById('recompute').addEventListener('click', () => {
                computeDelaunayVoronoi();
            });
            
            document.getElementById('periodicMode').addEventListener('change', () => {
                computeDelaunayVoronoi();
            });
            
            // Add event listeners for new geometric controls
            document.getElementById('pointDistribution').addEventListener('change', () => {
                updateControlsVisibility(); // Update control states
                
                // Generate new points (this matters for Voronoi mode)
                currentPoints = generatePoints();
                velocities = currentPoints.map(() => [(Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)]);
                
                // Always call computeDelaunayVoronoi - it will decide whether to compute or just draw shapes
                computeDelaunayVoronoi();
            });
            
            document.getElementById('spaceFillingType').addEventListener('change', () => {
                updateControlsVisibility(); // Update control states
                currentPoints = generatePoints();
                velocities = currentPoints.map(() => [(Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)]);
                computeDelaunayVoronoi();
            });
            
            document.getElementById('geometricScale').addEventListener('input', () => {
                currentPoints = generatePoints();
                velocities = currentPoints.map(() => [(Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)]);
                computeDelaunayVoronoi();
            });
            
            document.getElementById('honeycombDivisions').addEventListener('change', () => {
                currentPoints = generatePoints();
                velocities = currentPoints.map(() => [(Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)]);
                computeDelaunayVoronoi();
            });
            
            // Size and color controls
            document.getElementById('delaunaySize').addEventListener('change', () => {
                drawVertices(computation);
            });
            
            document.getElementById('vertexColor').addEventListener('change', () => {
                drawVertices(computation);
            });
            
            document.getElementById('delaunayEdgeColor').addEventListener('change', () => {
                drawMeshes(computation);
            });
            
            // NEW: Edge width controls
            document.getElementById('delaunayEdgeWidth').addEventListener('change', () => {
                drawMeshes(computation);
            });
            
            document.getElementById('voronoiSize').addEventListener('change', () => {
                drawMeshes(computation);
            });
            
            document.getElementById('voronoiVertexColor').addEventListener('change', () => {
                drawMeshes(computation);
            });

            document.getElementById('voronoiEdgeColor').addEventListener('change', () => {
                const pointDistribution = document.getElementById('pointDistribution').value;
                const spaceFillingType = document.getElementById('spaceFillingType').value;
                
                if (pointDistribution !== 'voronoi' || spaceFillingType !== 'none') {
                    drawGeometricShapes(); // Update geometric shapes with new edge color
                } else {
                    drawMeshes(computation);
                }
            });
            
            // NEW: Voronoi edge width control
            document.getElementById('voronoiEdgeWidth').addEventListener('change', () => {
                const pointDistribution = document.getElementById('pointDistribution').value;
                const spaceFillingType = document.getElementById('spaceFillingType').value;
                
                if (pointDistribution !== 'voronoi' || spaceFillingType !== 'none') {
                    drawGeometricShapes(); // Update geometric shapes
                } else {
                    drawMeshes(computation);
                }
            });
            
            document.getElementById('tetraColor').addEventListener('change', () => {
                drawTetrahedra(computation);
            });
            
            document.getElementById('tetraOpacity').addEventListener('change', () => {
                drawTetrahedra(computation);
            });
            
            // NEW: Event listeners for MIC and Ghost Cell controls
            document.getElementById('useMIC').addEventListener('change', () => {
                const pointDistribution = document.getElementById('pointDistribution').value;
                const spaceFillingType = document.getElementById('spaceFillingType').value;
                
                if (pointDistribution !== 'voronoi' || spaceFillingType !== 'none') {
                    drawGeometricShapes(); // Update geometric shapes
                } else {
                    drawMeshes(computation);
                    createGhostCellTiling();
                }
            });
            
            document.getElementById('showGhostCells').addEventListener('change', () => {
                const pointDistribution = document.getElementById('pointDistribution').value;
                const spaceFillingType = document.getElementById('spaceFillingType').value;
                
                if (pointDistribution === 'voronoi' && spaceFillingType === 'none') {
                    createGhostCellTiling();
                }
                // No need to do anything for geometric shapes
            });
            
            // NEW: Random Voronoi colors control
            document.getElementById('randomVoronoiColors').addEventListener('change', () => {
                drawVoronoiFaces(computation);
                createGhostCellTiling(); // Also update ghost cells
            });
            
            // NEW: Control panel toggle
            document.getElementById('controls-toggle').addEventListener('click', () => {
                const controls = document.getElementById('controls');
                const toggle = document.getElementById('controls-toggle');
                const content = document.getElementById('controls-content');
                
                if (controls.classList.contains('hidden')) {
                    controls.classList.remove('hidden');
                    content.style.display = 'block';
                    toggle.textContent = 'hide';
                    toggle.title = 'Hide Controls';
                } else {
                    controls.classList.add('hidden');
                    content.style.display = 'none';
                    toggle.textContent = 'show';
                    toggle.title = 'Show Controls';
                }
            });
            
            // Background color control
            document.getElementById('backgroundColor').addEventListener('change', (e) => {
                scene.background = new THREE.Color(e.target.value);
            });

            animate();
            
        }).catch(err => {
            console.error('Failed to load module:', err);
            setStatus('Failed to load module', false);
        });
    </script>
</body>
</html> 